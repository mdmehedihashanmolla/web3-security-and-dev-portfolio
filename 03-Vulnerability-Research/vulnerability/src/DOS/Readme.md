<div align="center">

# DENIAL OF SERVICE (DOS)

</div>

## 1. Gas Griefing - Intentional gas consumption

 Gas griefing is a vulnerability where an attacker manipulates a smart contract’s execution to consume excessive gas, either to cause a transaction to revert (due to hitting the block gas limit) or to make it prohibitively expensive for legitimate users to interact with the contract. Unlike traditional gas limit attacks that exploit unbounded loops, gas griefing often involves malicious external contracts or callbacks that deliberately burn gas.

### Mitigation Guide

- **Limit Gas on External Calls**: When sending ETH or calling another contract, don't give them unlimited gas. Set a safe gas cap so they can't waste all your gas and break the transaction.

- **Use Pull-Based Withdrawals**: Instead of sending funds to everyone directly, let each user withdraw their own funds. This way, if one user fails, it doesn't block others from getting their money.

- **Avoid External Calls in Critical Steps**: Do all your important updates first (like changing balances) before making external calls. This keeps the contract safe even if the external call fails.

- **Validate Recipients**: Only allow trusted wallets or safe addresses to receive funds. Don't blindly interact with unknown contracts that could try to attack your system.
  
------

## 2. Loop Attacks - Unbounded iterations

A loop attack (or unbounded iteration vulnerability) occurs when a smart contract uses a loop to iterate over a data structure (e.g., array or mapping) whose size is controlled by user inputs. If the data structure grows too large, the loop’s gas consumption exceeds the Ethereum block gas limit (e.g., ~30M gas as of 2025), causing the transaction to fail.

### Mitigation Guide

- **Cap Array Size**: Put a limit on how many participants or items can be stored. This prevents the loop from growing too big and running out of gas.

- **Break Large Loops into Smaller Parts (Pagination)**: Instead of processing a huge list in one go, handle it in smaller chunks (like pages). This way, the contract doesn't hit the gas limit in a single transaction.

- **Use Pull-Based Rewards**: Let users claim their rewards themselves, instead of sending rewards to everyone in one big loop. This avoids one failed transfer blocking the entire process.

- **Avoid Loops in Critical Functions**: Don't rely on loops for very important operations like withdrawals or balance updates. Use efficient data structures (like mappings) or do heavy processing off-chain to keep things safe.
  
------

## 3. DOS with Revert - Blocking execution with reverts

DoS with Revert happens when one failing action stops the whole function from running. In Solidity, if even one transfer or call reverts (fails), the entire transaction is canceled. For example, if a contract tries to pay 100 users in a loop, and just one user’s payment fails, nobody gets paid. Attackers can exploit this by making their payment always fail, blocking the whole process.

### Mitigation Guide

- **Use Pull Payments**: Instead of sending money directly to users, let them withdraw it themselves. This way, if one person's withdrawal fails, it doesn't block everyone else. **Trade-off**: Users need to take action and pay gas to claim their funds, but the system stays safe.

- **Handle Failed Transfers Gracefully**: If you must send money out, don't force the whole transaction to fail if one payment doesn't go through. Record the failure (e.g., log it or put it in a "retry later" list) so it can be fixed manually. **Trade-off**: Some funds may sit unclaimed until someone handles the failure.

- **Avoid External Calls in Critical Loops**: Don't rely on external contracts inside important loops. If one contract misbehaves and reverts, the loop won't stop others from being processed. **Trade-off**: Adds complexity, since you may need to split actions or add timeouts for problem users.