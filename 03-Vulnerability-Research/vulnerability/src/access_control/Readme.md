<div align="center">

# ACCESS CONTROL & AUTHORIZATION

</div>

## 1. Phishing with tx.origin

This vulnerability occurs when a contract uses tx.origin for authentication instead of msg.sender. Because tx.origin always points to the externally owned account (EOA) that started the transaction, an attacker can trick the legitimate owner into calling a malicious contract, which then forwards the call to the vulnerable contract. The vulnerable contract will incorrectly believe the original owner is interacting directly, allowing the attacker to drain funds.

### Mitigation Guide

- **Use `msg.sender` for Authorization**: Always rely on `msg.sender` to verify the immediate caller. For owner-only checks, confirm that `msg.sender` matches the stored owner address.
- **Avoid `tx.origin` Entirely**: It is unsafe and discouraged for access control. In rare cases where EOA detection is necessary, ensure additional checks so that only direct calls are allowed.
- **Follow Secure Patterns**: Rely on established libraries such as OpenZeppelin's `Ownable` or `AccessControl`. For higher security setups, use multisig wallets like Gnosis Safe or DAO-style roles. For sensitive or emergency functions, add layers such as signature verification or timelocks instead of depending on a single EOA.
  
------

## 2. Weak / Missing Access Control

This vulnerability happens when critical functions in a smart contract (such as withdraw, upgrade, or pause) are left unprotected or use insufficient checks. Without proper authorization, anyone can call these functions and perform actions that should only be allowed for the contract owner or administrators. This often leads to stolen funds, broken logic, or even complete takeover of the contract.

### Mitigation Guide

- **Enforce Strict Ownership Checks**: Ensure that only the designated owner or admin can call sensitive functions.
- **Use Battle-tested Libraries**: Implement OpenZeppelin's `Ownable` or `AccessControl` to standardize permissions and avoid mistakes.
- **Adopt Role-based Design**: Assign different roles (e.g., owner, admin, operator) instead of relying on a single EOA.
- **Secure High-risk Functions**: For actions like upgrades, withdrawals, or pausing contracts, add additional layers such as multi-sig wallets, timelocks, or signature approvals.
- **Regularly Review Access Logic**: During audits and testing, verify that all critical functions have proper access modifiers.
  
------

## 3. Function Visibility Issues

Function Visibility Issues, specifically public functions that should be private or internal, occur when functions intended for restricted or internal use are exposed publicly, allowing unauthorized access to sensitive operations. This vulnerability can lead to unintended state changes, fund theft, or protocol compromise. 

### Mitigation Guide

1. **Use `private` or `internal` Visibility**: Explicitly declare functions as `private` (only callable within the contract) or `internal` (callable within the contract and derived contracts) unless they need external access.
2. **Add Access Control Modifiers**: Use OpenZeppelin's `Ownable` or `AccessControl` for public functions that need restricted access.
3. **Explicit Caller Checks**: Add `require(msg.sender == owner)` or role-based checks for public functions.
4. **Default to Restricted Visibility**: Always specify visibility (`private`, `internal`, `public`, `external`) to avoid Solidity's default `public` visibility.