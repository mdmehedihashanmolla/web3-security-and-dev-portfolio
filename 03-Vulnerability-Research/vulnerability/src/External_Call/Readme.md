<div align="center">

# EXTERNAL CALL VULNERABILITIES

</div>

## 1. Storage Collision 

This vulnerability happens when two contracts accidentally use the same storage slot for different variables. This often occurs in proxy contracts that call another contract using delegatecall. Because Ethereum stores data in numbered slots (like boxes arranged in order), if the proxy and the implementation contract don’t follow the same variable order, their data can overlap. As a result, important values like the contract owner or user balances can get overwritten. An attacker can abuse this by creating or upgrading to a contract designed to overwrite those slots, gaining control of the contract or stealing funds.

### Mitigation Guide

- **Follow Standardized Storage Slots**  
  Use proxy standards like **EIP-1967** or **ERC-1822 (UUPS)** that define fixed storage slots for proxy-specific variables, preventing overlap with implementation storage.

- **Keep Storage Layout Consistent**  
  When upgrading contracts, always append new variables at the end of the storage layout instead of inserting them in between existing ones.

- **Use Gap Patterns**  
  Reserve empty storage slots (commonly `uint256[50] private __gap;`) in base contracts so future versions can safely add variables without colliding.

- **Rely on Well-Audited Libraries**  
  Use established implementations from **OpenZeppelin Upgrades** or other vetted libraries instead of writing custom proxy logic.

- **Test With Tools**  
  Leverage tools like **Slither**, **Foundry storage layout checks**, or **Hardhat plugins** to verify that storage layouts match across upgrades.

  
------

## 2. Unchecked Call Return Values

This vulnerability occurs when a Solidity contract uses low-level calls like address.call(), send(), or transfer() to interact with another contract or address but fails to check the return value of the call. If the call fails (e.g., due to insufficient gas, a revert, or an invalid address), the contract may continue execution, assuming success, which can lead to incorrect state updates, loss of funds, or unintended behavior.

### Mitigation Guide

- **Always check return values**  
  For low-level calls such as `call`, `send`, `delegatecall`, and token transfers, always validate the returned boolean value.

- **Use `require`**  
  Enforce successful execution by wrapping critical operations with `require(success, "Failure message");`.

- **Prefer `transfer` over `send`**  
  Use `transfer` for simplicity, but still handle edge cases like gas griefing. For maximum control, use `call` with explicit checks.

  
------

## 3. Delegatecall Exploitation

This vulnerability happens when a contract uses delegatecall to run code from another contract (like in proxy patterns) without making sure the other contract is safe. Because delegatecall runs the external code using the proxy’s storage, an attacker who controls or tricks the implementation contract can change important data, like the contract owner or user balances. This can let the attacker take over the contract or steal funds if proper access checks and storage layouts are not followed.

### Mitigation Guide

- **Restrict Implementation Access**  
  Only allow trusted accounts (like multisig wallets) to upgrade or change the implementation contract. Never leave upgrade functions open to the public.

- **Use Well-Audited Libraries**  
  Rely on established proxy implementations such as **OpenZeppelin's UUPS** or **TransparentUpgradeableProxy** to handle upgrades safely.

- **Keep Storage Layout Consistent**  
  Ensure that the storage layout of the proxy and the implementation contract matches perfectly to avoid overwriting critical variables.

- **Validate Implementation Contracts**  
  Before upgrading, thoroughly review and audit the new implementation for malicious or unsafe code.

- **Add Extra Security Layers**  
  Consider timelocks, multisig approvals, or signature verification for upgrades to prevent single-point compromises.
