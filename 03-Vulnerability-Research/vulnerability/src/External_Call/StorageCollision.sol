// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Contract A - Vulnerable to storage collision
contract ContractA {
    address public owner;       // Storage slot 0
    uint256 public userCount;   // Storage slot 1
    mapping(address => uint256) public balances; // Storage slot 2 (for mapping base)

    constructor() {
        owner = msg.sender;
        userCount = 0;
    }

    function addUser(address user, uint256 balance) external {
        require(msg.sender == owner, "Not owner");
        userCount++;
        balances[user] = balance;
    }
}

// Contract B - Malicious contract with different storage layout
contract ContractB {
    // WARNING: Different storage layout than ContractA!
    address public attacker;    // Storage slot 0 - COLLIDES with ContractA.owner!
    uint256 public stolenFunds; // Storage slot 1 - COLLIDES with ContractA.userCount!
    address public victimContract; // Storage slot 2

    function setVictim(address _victim) external {
        victimContract = _victim;
    }

    function exploit() external {
        // This will corrupt ContractA's storage!
        attacker = msg.sender; // Overwrites ContractA.owner at slot 0!
        stolenFunds = 1000;    // Overwrites ContractA.userCount at slot 1!
    }

    function getBalance() external view returns (uint256) {
        return address(victimContract).balance;
    }
}

// Contract C - Safe contract with same storage layout
contract ContractC {
    // Same storage layout as ContractA
    address public owner;       // Storage slot 0
    uint256 public userCount;   // Storage slot 1  
    mapping(address => uint256) public balances; // Storage slot 2

    function safeFunction() external {
        // This is safe because storage layout matches
        userCount = 999;
    }
}