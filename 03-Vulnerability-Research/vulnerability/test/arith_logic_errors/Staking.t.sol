// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Staking} from "../../src/arith_logic_errors/Staking.sol";

contract StakingTest is Test {
    Staking public staking;
    address user1 = makeAddr("user1");
    address user2 = makeAddr("user2");
    address user3 = makeAddr("user3");

    function setUp() public {
        staking = new Staking();
    }

    function testOffByOneVulnerability() public {
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);
        vm.deal(user3, 10 ether);

        vm.prank(user1);
        staking.stake{value: 1 ether}(1 ether);

        vm.prank(user2);
        staking.stake{value: 2 ether}(2 ether);

        vm.prank(user3);
        staking.stake{value: 3 ether}(3 ether);

        assertEq(staking.totalStaked(), 6 ether, "Total staked should be 6 ETH");

        address[] memory stakers = staking.getStakers();
        assertEq(stakers.length, 3, "Should have 3 stakers");
        assertEq(stakers[0], user1, "First staker should be user1");
        assertEq(stakers[1], user2, "Second staker should be user2");
        assertEq(stakers[2], user3, "Third staker should be user3");

        vm.deal(address(staking), 10 ether);

        uint256 balance1Before = user1.balance;
        uint256 balance2Before = user2.balance;
        uint256 balance3Before = user3.balance;

        staking.distributeRewards();

        uint256 balance1After = user1.balance;
        uint256 balance2After = user2.balance;
        uint256 balance3After = user3.balance;

        assertEq(balance1After - balance1Before, 0, "user1 should receive NO rewards (skipped)");

        assertEq(balance2After - balance2Before, 0.2 ether, "user2 should receive 0.2 ETH rewards");

        assertEq(balance3After - balance3Before, 0.3 ether, "user3 should receive 0.3 ETH rewards");

        console.log("user1 rewards:", balance1After - balance1Before, "(SKIPPED due to off-by-one)");
        console.log("user2 rewards:", balance2After - balance2Before);
        console.log("user3 rewards:", balance3After - balance3Before);
    }

    function testSingleStakerGetsSkipped() public {
        vm.deal(user1, 10 ether);

        vm.prank(user1);
        staking.stake{value: 1 ether}(1 ether);

        vm.deal(address(staking), 1 ether);

        uint256 balanceBefore = user1.balance;
        staking.distributeRewards();
        uint256 balanceAfter = user1.balance;

        assertEq(balanceAfter - balanceBefore, 0, "Single staker gets NO rewards due to off-by-one");
    }
}
