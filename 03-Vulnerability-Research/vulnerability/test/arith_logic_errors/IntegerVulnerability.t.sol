// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {IntegerVulnerability} from "../../src/arith_logic_errors/IntegerVulnerability.sol";

contract IntegerVulnerabilityTest is Test {
    IntegerVulnerability public integerVulnerability;

    function setUp() public {
        integerVulnerability = new IntegerVulnerability();
    }

    function testUnderFlow() public {
        assertEq(integerVulnerability.getBalance(), 0, "Initial Balance must be 0");

        integerVulnerability.deductBalance(1);
        uint256 maxUnits256 = type(uint256).max;

        assertEq(integerVulnerability.getBalance(), maxUnits256, "Balance should underflow to max unit256");
    }

    function testUnderFlowWithNonZeroBalance() public {
        integerVulnerability.addBalance(100);
        assertEq(integerVulnerability.getBalance(), 100, "Balance should be 100");

        integerVulnerability.deductBalance(101);

        uint256 expected = type(uint256).max;
        assertEq(integerVulnerability.getBalance(), expected, "Balance should underflow to max uint256");
    }

    function testNormalDeduction() public {
        integerVulnerability.addBalance(100);
        assertEq(integerVulnerability.getBalance(), 100, "Balance should be 100 after adding");

        integerVulnerability.deductBalance(50);
        assertEq(integerVulnerability.getBalance(), 50, "Balance should be 50 after deduction");

        integerVulnerability.deductBalance(50);
        assertEq(integerVulnerability.getBalance(), 0, "Balance should be 0 after full deduction");
    }

    function testMultipleUnderFlows() public {
        integerVulnerability.deductBalance(1); // First underflow

        uint256 firstUnderflow = integerVulnerability.getBalance();

        assertEq(firstUnderflow, type(uint256).max, "First underflow should give max uint256");

        integerVulnerability.deductBalance(1);

        uint256 secondUnderflow = integerVulnerability.getBalance();

        assertEq(secondUnderflow, type(uint256).max - 1, "Second underflow should give max-1");
    }
}
