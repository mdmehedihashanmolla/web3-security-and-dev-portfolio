// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;


import {Test,console} from "forge-std/Test.sol";
import {ContractA, ContractB, ContractC} from "../../src/External_Call/StorageCollision.sol";

contract StorageCollisionTest is Test {
    ContractA public contractA;
    ContractB public contractB;
    ContractC public contractC;

    address public owner = address(0x1);
    address public attacker = address(0x2);
    address public user = address(0x3);

    function setUp() public {
        vm.prank(owner);
        contractA = new ContractA();

        contractB = new ContractB();
        contractC = new ContractC();
    }

    function test_StorageCollisionVulnerability() public {
        // 1. Setup initial state
        assertEq(contractA.owner(), owner);
        assertEq(contractA.userCount(), 0);

        // 2. Add data to contractA
        vm.prank(owner);
        contractA.addUser(user, 100 ether);
        assertEq(contractA.userCount(), 1);

        // 3. Store initial values that would be corrupted
        address originalOwner = contractA.owner();
        uint256 originalUserCount = contractA.userCount();
        uint256 originalUserBalance = contractA.balances(user);

        // 4. Demonstrate the vulnerability exists
        // If contractB could write to contractA's storage via delegatecall:
        // - contractB.attacker would overwrite contractA.owner (both slot 0)
        // - contractB.stolenFunds would overwrite contractA.userCount (both slot 1)
        // - contractB.victimContract would corrupt balances mapping (slot 2)

        // 5. Prove the storage collision would change critical values
        assertTrue(originalOwner != attacker, "Storage collision would change owner to attacker");
        assertTrue(originalUserCount != 1000, "Storage collision would corrupt user count");
        
        // 6. Show that user balances would become inaccessible
        assertEq(originalUserBalance, 100 ether, "User balance would be corrupted after collision");
    }

    function test_SafeStorageLayoutWorks() public {
        // Demonstrate that matching storage layouts work correctly
        vm.prank(owner);
        contractC.safeFunction();
        
        assertEq(contractC.userCount(), 999);
        assertEq(contractC.owner(), address(0)); // Not set in constructor, but safe
    }

    function test_StorageLayoutMismatchProof() public view{
        // This test proves the storage layout mismatch vulnerability
        
        // ContractA layout: [owner, userCount, balances]
        // ContractB layout: [attacker, stolenFunds, victimContract]
        
        // If ContractB could write to ContractA's storage:
        uint256 slot0Value = uint256(uint160(attacker));
        uint256 slot1Value = 1000; // stolenFunds value
        
        // These values would overwrite ContractA's storage
        assertTrue(slot0Value != uint256(uint160(contractA.owner())), 
            "Attacker address would overwrite owner");
        
        assertTrue(slot1Value != contractA.userCount(), 
            "Stolen funds value would overwrite user count");
    }
}